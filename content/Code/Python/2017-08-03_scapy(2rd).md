TITLE: scapy 总结（二）  
Tags: python, 小结



关于字节流中恢复包， 定义新的协议以及sniff 源码分析

从字节流中恢复包
-------------
```
from scapy.all import Ether
b = bytes(pkt)
r = Ether(b)
```


`Packet` 类和其子类
------------------
在 scapy 中， 定义了一些类， 用于处理不同层中的数据， 层和层之间存在上下关系。 每一层只解析对应的数据， 其余的被当成 `payload` 存放。比如`Ether`只解析 mac 地址， 之后 IP 层的数据都存在 payload 中。

在当前层解析完成之后， 余下的 payload会调用`guess_payload_class`来猜测下一层需要使用的类， 之后交由下一层来解析剩下的 payload。

`Ether` `IP` `UDP` `TCP`等都是`Packet`的子类，每一层都定义了 field， 存放于`field_desc`中， field 为 descriotor， 用于处理数据类型， 类似于 django model 中的`Field`。

比如定义一个新的 layer

```python
class Disney(Packet):
    name = "DisneyPacket "
    fields_desc=[ ShortField("mickey",5),
                 XByteField("minnie",3) ,
                 IntEnumField("donald" , 1 ,
                      { 1: "happy", 2: "cool" , 3: "angry" } ) ]

```

具体可以参考 http://scapy.readthedocs.io/en/latest/build_dissect.html  

###自带的包序列化
文档里面没有提及， 我翻源码的时候看到有`import_object` 和`export_object`函数， 用于把包序列化。  代码位于 `utils.py` 中

``` python
def export_object(obj):
    import dill as pickle
    import base64
    return base64.b64encode(gzip.zlib.compress(pickle.dumps(obj,4),9)).decode('utf-8')
```

返回 pickle 序列化后压缩然后 b64编码的值。  


###sniff 函数源码分析  

```python  

def sniff(count=0, store=1, offline=None, prn = None, lfilter=None, L2socket=None, timeout=None,
          opened_socket=None, stop_filter=None, exceptions=False, *arg, **karg):
    c = 0
    if opened_socket is not None:
        s = opened_socket
    else:
        if offline is None:
            if L2socket is None:
                L2socket = conf.L2listen
            s = L2socket(type=ETH_P_ALL, *arg, **karg)
        else:
            s = PcapReader(offline)

    lst = []
    if timeout is not None:
        stoptime = time.time()+timeout
    remain = None
    try:
        while 1:
            if timeout is not None:
                remain = stoptime-time.time()
                if remain <= 0:
                    break
            sel = select([s],[],[],remain)
            if s in sel[0]:
                p = s.recv(MTU)
                if p is None:
                    break
                if lfilter and not lfilter(p):
                    continue
                if store:
                    lst.append(p)
                c += 1
                if prn:
                    r = prn(p)
                    if r is not None:
                        print(r)
                if stop_filter and stop_filter(p):
                    break
                if count > 0 and c >= count:
                    break
    except KeyboardInterrupt:
        if exceptions:
            raise
        else:
            pass
    finally:
        if opened_socket is None:
            s.close()

    return plist.PacketList(lst,"Sniffed")
```

首先初始化`c`，用于无条件统计包的个数， 初始化`s`， 该对象的来源有三种途径， 从`opened_socket`参数设置一个给定的打开的 socket 对象， 或者是在 `offline`设定了文件路径的时候使用`PcapReader`, 最后使用默认的`L2listen`.  
之后进入循环， 使用`select`监听s 的可读事件， 每次读入之后对包做处理， 先用`lfilter`, 然后判断`store`为真将包存入列表中， 使用`prn`设置的函数,使用`stop_filter`设置的函数， 判断 c 和 count 的大小， 是否退出循环。  

函数捕获 `KeyboardInterrupt`异常， 循环结束后返回存储的列表。  

有几个不是很好的地方， 一个是 变量c默认不断的累加包数量， 另一个是 select 的超时参数被用于设置 sniff 的监听时间了，  在设置为无限运行时， sniff会在没有包到来的时候永久阻塞， 由于判断退出的回调函数是在处理每个包时调用的， 所以无法正常的退出。

如果你希望 sniff 函数作为线程长期运行，但是又希望能在没有包到来的情况下按时的退出， 一种是发送一自定义的包， 触发 stop_filter函数， 另一种是修改 sniff 源码，select 的 timeout 参数设置为一个 sweep timeout， 用于定时的结束 select 的 block， 然后检查循环是否需要退出。



2017年08月03日17:23:46

 