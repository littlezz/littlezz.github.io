Title: Scapy 使用总结  
Tags: python, 小结  


###构造包以及一些网络基础知识
载入所有函数  

```
from scapy.all import *
```

或者从命令行输入`sudo scapy`


scapy 可以控制各个层的数据， 使用`/`符号拼合各个层构造出一个包

```python
packet = IP(dst='192.168.1.1', src='192.168.1.2')/ UDP(sport=5555, dport=4444)/ b'udp data'

packet.show()

print(bytes(packet))
```

IP层控制 ip 地址， 对于 udp 包来说不需要握手可以伪造源地址。UDP 是和 TCP 平行的一层， 控制发包的源端口和目标端口。  
再后面一层是要发送的数据。  

`packet.show()` 工整的打印包数据



###发送包

scapy 有几种发包的方式。  
`send`用于发送 layer3 层的包， 也就是程序自动处理链路层上面的 mac 地址， 如果想要自定义 mac 地址， 需要使用 sendp， 这是在 layer2 层发包， 这个时候可以自定义 mac 地址。

```
send(packet)
sendp(p, iface='en0')
packet = Ether(src=RandMAC())/IP(dst='192.168.31.1')/UDP(dport=33331)/b'message'
sendp(packet)
```  

`sendp`可以指定发送的 iface。同时可以构造包的时候加入构造`Ether()`

###UDP广播
子网内的机器在接受数据时是这样一个流程。  
当数据包从网卡流过的时候， 网卡检查数据包的目标 mac 地址是否包含于自己等待的地址中（既网卡可以监听多个 mac 地址）， 符合就吧数据包拷贝一份向上层传输， 之后检查目标 IP 是否和自己监听的 ip 地址之一符合， 如果符合再交由上层处理， 如果不符合， 则看自己是否配置了路由功能， 然后根据路由表选择出口， 如果没有就从默认路由出去。  

之所以有 ip 和 mac 之分， 是因为 mac 地址的表示是48位的， 而网络协议的 ip 是32位的。  

所以在进行广播的时候， 把目标 mac 地址设置为`ff:ff:ff:ff:ff:ff`, 对于绝大部分机器网卡都会接受这个地址。


一种是受限广播， 目标 ip 设置为`255.255.255.255`， mac 地址设置为`ff:ff:ff:ff:ff:ff`， 这种方式路由器不对目的 ip 为`255.255.255.255` 进行转发，改数据报只在该子网中出现。  

另一种是指向子网的广播， `xxx.xxx.xxx.255`， 数据包会被转发到该子网内广播。  

在 scapy 中， 可以直接把地址设置为`255.255.255.255`来广播， 但是会得到  

`WARNING: Mac address to reach destination not found. Using broadcast.`

这是因为使用 `send` 函数的缘故， 这个函数作用于 layer3 ， 自动组装了 layer2 层的东西， 目的 mac 地址这个时候就会在 arp 表中查询， 然而广播地址的 mac 地址是查不到的， 这个时候它就会提示程序自动把目的地址mac设置成了广播用的 mac

####solution
使用`sendp`来发送包， 手动设置packet `Ether`的 `dst` 地址

```
packet = Ether(dst='ff:ff:ff:ff:ff:ff')/IP(dst='192.168.31.255')/UDP(dport=33331)/b'message'
sendp(packet)
```

值得注意的是， `sendp`是可以使用指定的 interface 来发送包，默认情况下使用`conf.iface`的设备



###重放攻击
`sniff`用于监听网络流量， sniff 是阻塞的，可以使用回调函数来处理每一个捕获到的包。  同时可以使用 filter 参数过滤要捕获的包，也可以指定用于监听的 interface， 默认使用所有设备来监听  

filter 的语法和 tcpdump 中用于过滤的语法一样， 可以使用`man pcap-filter`查看详细的内容。

```
sniff(filter='udp dst port 2333', prn=lamda pkt: pkt.show())
```

这段代码循环监听 目标端口为2333的 udp 包， 然后回调程序吧这个包展示出来。  

之后可以吧收到的包再发出去， 完成一次重放（UDP）

```
sniff(prn=lambda pkt:sendp(pkt))
```

如果是 tcp 的重放，需要修改 ack。  







